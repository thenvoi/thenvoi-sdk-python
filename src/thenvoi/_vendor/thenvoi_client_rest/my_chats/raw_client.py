# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.error import Error
from ..types.validation_error import ValidationError
from .types.list_my_chats_request_status import ListMyChatsRequestStatus
from .types.list_my_chats_response import ListMyChatsResponse


class RawMyChatsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_my_chats(
        self,
        *,
        page: typing.Optional[int] = None,
        per_page: typing.Optional[int] = None,
        status: typing.Optional[ListMyChatsRequestStatus] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListMyChatsResponse]:
        """
        Returns a paginated list of all chat rooms where you are a participant.

        Chat rooms can be filtered by status and include information about your role
        in each room (member, moderator, or admin). The list shows only rooms you have
        access to based on your participation.

        Parameters
        ----------
        page : typing.Optional[int]
            Page number for pagination

        per_page : typing.Optional[int]
            Number of items per page

        status : typing.Optional[ListMyChatsRequestStatus]
            Filter by chat room status (active, archived, or closed)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListMyChatsResponse]
            Chat Rooms
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/me/chats",
            method="GET",
            params={
                "page": page,
                "per_page": per_page,
                "status": status,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyChatsResponse,
                    parse_obj_as(
                        type_=ListMyChatsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawMyChatsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_my_chats(
        self,
        *,
        page: typing.Optional[int] = None,
        per_page: typing.Optional[int] = None,
        status: typing.Optional[ListMyChatsRequestStatus] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListMyChatsResponse]:
        """
        Returns a paginated list of all chat rooms where you are a participant.

        Chat rooms can be filtered by status and include information about your role
        in each room (member, moderator, or admin). The list shows only rooms you have
        access to based on your participation.

        Parameters
        ----------
        page : typing.Optional[int]
            Page number for pagination

        per_page : typing.Optional[int]
            Number of items per page

        status : typing.Optional[ListMyChatsRequestStatus]
            Filter by chat room status (active, archived, or closed)

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListMyChatsResponse]
            Chat Rooms
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/me/chats",
            method="GET",
            params={
                "page": page,
                "per_page": per_page,
                "status": status,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyChatsResponse,
                    parse_obj_as(
                        type_=ListMyChatsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
